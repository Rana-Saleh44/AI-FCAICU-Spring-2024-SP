Solving Problems by Searching
Chapter Outline
◼ Problem-solving agents
◼ Problem types
◼ Problem formulation
◼ Example problems
◼ Uninformed (Blind) search
◼ Informed (Heuristic) search

Why Search ?
◼ Early works of AI was mainly towards
– Theorems proving
– Solving puzzles
– Playing games
◼ All AI is search!
– Not totally true (obviously) but more true than you might think.
– All life is problem solving !!
– Finding a good/best solution to a problem between many possible solutions.

Classic AI Search Problems
◼ Map searching (navigation)
◼ 6*3*3 Rubik’s Cube
◼ 8-Puzzle
◼ N-Queens
◼ Missionaries and cannibals
◼ The River Problem

Map Searching (navigation)
◼ On touring holiday in Romania; currently in Arad.
◼ Flight leaves tomorrow from Bucharest
– Non-refundable ticket.
◼ Formulate goal:
– be in Bucharest on time
◼ Formulate problem:
– states: various cities
– actions: drive between cities
◼ Find solution (action sequences):
– sequence of cities, e.g., Arad, Sibiu, Fagaras, Bucharest

Problem-Solving Agents check slide 8
◼ A kind of goal-based agents that decide what to do by
finding sequences of actions that lead to desirable states.
◼ Goals help to organize behavior by limiting the
objectives that the agent is trying to achieve.
◼ Goal formulation is the first step in problem solving,
based on the currentsituation and the agent’s performance measure.
– As well as formulating a goal, the agent may wish to decide
on some other factors that affect the desirability of different
ways of achieving the goal.
◼ Problem formulation is the process of deciding what
actions and statesto consider, given the goal formulation.
◼ An agent with several immediate options of unknown
value can decide what to do by first examining different
possible sequences of actions that lead to states of
known value, and then choosing the best sequences.
– This process of looking for such a sequence is called search.
– A search algorithm takes a problem as input and returns a
solution in the form of an action sequence.
– Once a solution is found, the actions it recommends can be
carried out through the execution phase.
◼ Thus, the agent design is simply consists of “formulate,
search, execute” phases.
– Once the solution has been executed, the agent will formulate
a new goal.
◼ The agent design assumes that:
– The environment is static, because formulating and solving
the problem is done without paying attention to any changes
that might be occurring in the environment.
– The initial state is known; knowing it is easiest if the
environment is observable.
– The environment can be viewed as discrete to allow
enumerating “alternative courses of action”.
– Finally and most importantly, the environment is deterministic.
◼ Solutions to problems are single sequence of actions
and cannot handle any unexpected events.
◼ Solutions are executed without paying attention to the
percepts!!


Problem Types
◼ There are four essentially different types of problems:
– Single-state problems
» The agent’s sensors provide enough information for the agent to tell
exactly which state it is in => Fully observable.
» The agent knows exactly the effects of all its actions => Deterministic.
» Then, the agent can calculate exactly which state it will be in after any
sequence of actions.
– Multiple-state (sensorless) problems
» The agent is not certain about which state in a given set of states it is in
(has limited access to the world state) => Non-observable.
» The agent knows exactly the effects of all its actions => Deterministic.
» the agent must reason about sets of states that it might get to, rather
than single states.
– Contingency problems
» Nondeterministic and/or partially observable
» Solving this problem requires sensing during the execution phase.
◼ Percepts provide new information about current state
» The agent must now calculate a whole tree of actions, rather than a
single action sequence.
◼ Each branch of the tree deals with a possible contingency that might arise.
– Exploration problems
» Unknown state space (as lost in a desert without a map)
» The agent must experiment, gradually discovering what its actions do
and what sorts of states exist.
» This is a kind of search, but a search in the real world rather than in a
model thereof.
» If it survives, the agent learns a "map" of the environment, which it can
then use to solve subsequent problems.

check slide 12,13,14,15
Example: Vacuum World
Example: Single-state Problem
Example: Multiple-state Problem
Example: Contingency Problem

Well-defined Problems and Solutions
◼ A problem is really a collection of information that the
agent will use to decide what to do.
◼ A problem can be defined formally by five components:
– The initial state that the agent starts in.
– A description of the possible actions available to the agent.
– A description of what each action does; named transition model.
– The goal test, which determines whether a given state is a goal state.
– A path cost function that assigns a numeric cost to each path.
◼ A problem is really a collection of information that the
agent will use to decide what to do.
◼ A problem can be defined formally by five components:
– The initial state that the agent starts in.
– A description of the possible actions available to the agent.
» Given a particular state s, ACTIONS(s) returns the set of actions that
can be executed in s.
» We say that each of these actions is applicable in s.
– A description of what each action does; named transition
model.
– The goal test, which determines whether a given state is a
goal state.
– A path cost function that assigns a numeric cost to each path.
◼ A problem is really a collection of information that the
agent will use to decide what to do.
◼ A problem can be defined formally by five components:
– The initial state that the agent starts in.
– A description of the possible actions available to the agent.
– A description of what each action does; named transition
model.
» specified by a function RESULT(s, a) that returns the state that results
from doing action a in state s.
» We also use the term successor to refer to any state reachable from a
given state by a single action.
– The goal test, which determines whether a given state is a
goal state.
– A path cost function that assigns a numeric cost to each path.
◼ A problem is really a collection of information that the
agent will use to decide what to do.
◼ A problem can be defined formally by five components:
– The initial state that the agent starts in.
– A description of the possible actions available to the agent.
– A description of what each action does; named transition
model.
– The goal test, which determines whether a given state is a
goal state.
» Sometimes there is an explicit set of possible goal states, and the test
simply checks whether the given state is one of them.
» Sometimes the goal is specified by an abstract property.
– A path cost function that assigns a numeric cost to each path.

Single-state Problem Formulation check slide 20














